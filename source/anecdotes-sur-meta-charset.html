<!DOCTYPE html>
<html lang="fr-FR">
<title>Anecdotes sur meta charset</title>
<meta name="viewport" content="width=device-width">
<link rel="stylesheet" href="assets/common.css">
<link rel="stylesheet" href="assets/article.css">
<h1>Anecdotes sur <code>meta</code> <code>charset</code></h1>
<p>La ligne de code suivante vous est probablement familiÃ¨reÂ :</p>
<link rel="stylesheet" href="assets/code.css">
<pre><code class=" text.html.basic">&lt;meta charset=&quot;utf-8&quot;&gt;</code></pre>
<p>
    Elle est un moyen dâ€™indiquer aux <i lang="en">user agents</i>
    lâ€™encodage du document HTML dans lequel elle se trouve.
</p>
<p>Aussi familiÃ¨re quâ€™elle soit, saviez-vous ce qui suitÂ ?</p>

<h2>Elle est rÃ©trocompatible</h2>
<p>
    Il peut sembler Ã©trange dâ€™avoir introduit un nouvel attribut <code>charset</code> plutÃ´t que dâ€™utiliser
    <code>name</code> et <code>content</code>Â ; câ€™est en fait un moyen ingÃ©nieux de raccourcir la dÃ©claration
</p>
<pre><code class=" text.html.basic">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</code></pre>
<p>
    <code>http-equiv</code> avait Ã  lâ€™origine pour but de dÃ©finir des directives pour le serveur, mais cela nâ€™est
    jamais arrivÃ©. DÃ©finir lâ€™encodage est donc devenu le problÃ¨me du navigateur, en plus du support de syntaxes
    invalides. Lâ€™absence de guillemets autour dâ€™un attribut contenant une espace par exempleÂ :
</p>
<pre><code class=" text.html.basic">&lt;meta http-equiv=Content-Type content=text/html; charset=utf-8&gt;</code></pre>
<p>
    <code>charset</code> devient alors un attributÂ ! Sâ€™il est dÃ©jÃ  supportÃ©, il ne reste quâ€™Ã  le rendre valide.
    On supprime Ã©galement les attributs <code>http-equiv</code> et <code>content</code> devenus inutiles, et paf.
</p>
<aside>
    <blockquote lang="en">
        The rationale for the <code>&lt;meta charset=&quot;&quot;&gt;</code> attribute combination is that UAs
        already implement it
        <footer><a href="https://lists.w3.org/Archives/Public/public-html/2007Jul/0550.html" hreflang="en">https://lists.w3.org/Archives/Public/public-html/2007Jul/0550.html</a></footer>
    </blockquote>
</aside>

<h2><code>utf-8</code> est obligatoire</h2>
<p>
    Suite Ã  une <a href="https://github.com/whatwg/html/pull/3091" lang="en" hreflang="en">pull request</a>
    fusionnÃ©e fin 2017, <code>utf-8</code> devient la seule valeur (insensible Ã  la casse) admise pour toute dÃ©claration
    dâ€™encodage. En consÃ©quence, UTF-8 est maintenant le seul encodage valide pour un document.
</p>
<p>Cette dÃ©cision se base sur deux argumentsÂ :</p>
<ul>
    <li>La gestion de diffÃ©rents encodages a progressÃ© de maniÃ¨re anarchique, on va donc la stopper.</li>
    <li>
        UTF-8 est conÃ§u pour coder un jeu de caractÃ¨res <strong>universel</strong>Â :
        <a href="https://fr.wikipedia.org/wiki/ISO/CEI_10646"><abbr title="Universal Character Set" lang="en">UCS</abbr></a>.
        Il est donc inutile de supporter de nouveaux encodages.
    </li>
</ul>
<p>
    Dans un soucis de rÃ©trocompatibilitÃ©, le
    <abbr title="Web Hypertext Application Technology Working Group" lang="en">WHATWG</abbr> a spÃ©cifiÃ© quels encodages
    doivent continuer Ã  Ãªtre supportÃ©sÂ â€” et commentÂ â€” dans son
    <a href="https://encoding.spec.whatwg.org/" hreflang="en">Encoding standard</a>.
    La promotion dâ€™UTF-8 rend toutefois leur utilisation <strong>invalide</strong>.
</p>

<h2>Il y a mieux Ã  faire</h2>
<p>
    Imaginez un livre dâ€™<a href="https://fr.wikipedia.org/wiki/Anaglyphe">anaglyphes</a> dans lequel se trouve une
    paire de lunettes 3D. Vous allez tout dâ€™abord devoir feuilleter le livre pour les trouver, puis vous pourrez les
    utiliser pour profiter de son contenu.
</p>
<figure>
    <img
        src="assets/anecdotes-sur-meta-charset/anaglyph.jpg"
        alt="Anaglyph of Saguaro National Park at dusk."
        width="800"
        height="633"
    >
    <figcaption>Un anaglyphe est une image imprimÃ©e pour Ãªtre vue en relief.</figcaption>
</figure>
<p>
    De la mÃªme faÃ§on, dÃ©clarer lâ€™encodage dâ€™un document dans ce mÃªme document force le <i lang="en">user agent</i> Ã 
    trouver cette dÃ©claration avant de pouvoir parser le document. Dans un soucis dâ€™optimisation, vous Ãªtes tenus de
    la faire tenir dans les 1Â 024 premiers octets, ce qui permet dâ€™abandonner la recherche cette limite passÃ©e.
</p>
<aside>
    <blockquote lang="en">
        The authoring conformance requirements for character encoding declarations limit them to only appearing in the
        first 1024 bytes. User agents are therefore encouraged [â€¦] not to stall beyond that.
        <footer><a href="https://html.spec.whatwg.org/multipage/parsing.html#encoding-sniffing-algorithm" hreflang="en">https://html.spec.whatwg.org/multipage/parsing.html#encoding-sniffing-algorithm</a></footer>
    </blockquote>
</aside>
<p>
    Si nous filons la mÃ©taphore, cela revient Ã  ne chercher les lunettes quâ€™entre un nombre limitÃ© de pages. Il serait
    plus judicieux de les placer en dehors du livre, afin de pouvoir les chausser avant son ouverture.
    En lâ€™occurence nous pouvons spÃ©cifier lâ€™encodage dâ€™un document via le paramÃ¨tre <code>charset</code> de lâ€™en-tÃªte
    <code>Content-Type</code>. Ainsi le <i lang="en">user agent</i> pourra commencer le <i lang="en">parsing</i> dÃ¨s
    rÃ©ception du document.
</p>
<aside>
    <pre><code class=" source.http">Content-Type: text/html; charset=utf-8</code></pre>
</aside>
<p>Si vous nâ€™Ãªtes pas en mesure de configurer le serveur, deux solutionsÂ :</p>
<ul>
    <li>
        Votre document doit Ãªtre encodÃ© en UTF-8Â ; vous pouvez donc prÃ©fixer son contenu dâ€™un
        <abbr lang="en" title="Byte Order Mark">BOM</abbr>.
        <a href="https://www.w3.org/International/questions/qa-byte-order-mark#problems" hreflang="en">&Agrave; vos risques et pÃ©rils.</a>
    </li>
    <li>Utilisez <code>&lt;meta charset=&quot;utf-8&quot;&gt;</code> qui existe justement pour pallier cette situation.</li>
</ul>
<aside>
    <blockquote lang="en">
        <strong>To address server or configuration limitations</strong>, HTML documents may include explicit
        information about the documentâ€™s character encoding; the META element can be used to provide user agents with
        this information.
        <footer><a href="https://www.w3.org/TR/html401/charset.html#spec-char-encoding" hreflang="en">https://www.w3.org/TR/html401/charset.html#spec-char-encoding</a></footer>
    </blockquote>
</aside>

<h2><code>charset</code> nâ€™est pas <i lang="en">character set</i></h2>
<p>
    Mais ces deux termes peuvent dÃ©signer une <i lang="en">character map</i>.
    La faute Ã  un manque de discernement entre les diffÃ©rentes composantes dâ€™un encodage.
</p>
<p>
    Heureusement, une terminologie a Ã©tÃ© proposÃ©e par le Consortium Unicode en 1998 et standardisÃ©e en 2004 dans
    son <a href="https://www.unicode.org/reports/tr17/" hreflang="en" lang="en">Unicode Technical Report #17</a>Â :
    le <i lang="en">Unicode Character Encoding Model</i>. Quelles sont ses dÃ©finitionsÂ ?
</p>

<h3><i lang="en">Character set</i></h3>
<p>
    Ce terme vient de la terminologie dâ€™IBMÂ :
    <a href="https://www.ibm.com/docs/en/i/7.4?topic=representation-encoding-scheme" hreflang="en"><abbr title="Character Data Representation Architecture" lang="en">CDRA</abbr></a>
    oÃ¹ il dÃ©signe un ensemble de caractÃ¨res Ã  encoder. Par exemple
    <a href="https://fr.wikipedia.org/wiki/American_Standard_Code_for_Information_Interchange#Table_des_128_caract%C3%A8res_ASCII">ASCII</a>
    dÃ©finit un jeu de 128 caractÃ¨res fermÃ©, ce qui signifie quâ€™aucun caractÃ¨re ne lui sera ajoutÃ©.
    En comparaison celui dâ€™Unicode (le <i lang="en">Universal Character Set</i>) est ouvert et compte 137Â 928 caractÃ¨res
    dans sa version 12 (oÃ¹ 554 ont Ã©tÃ© ajoutÃ©s).
</p>
<p>Pour Ã©viter toute ambiguÃ¯tÃ©, on prÃ©fÃ¨rera parler dâ€™<strong lang="en">Abstract Character Repertoire</strong>.</p>

<h3><i lang="en">Charset</i></h3>
<p>
    Lâ€™origine de sa dÃ©finition actuelle vient de <a href="https://www.ietf.org/rfc/rfc2130.txt" hreflang="en">la
    proposition de terminologie de lâ€™<abbr title="Internet Architecture Board" lang="en">IAB</abbr></a>Â :
    <q>la mise en correspondance dâ€™une sÃ©quence de caractÃ¨res vers une sÃ©quence dâ€™octets sÃ©rialisÃ©e</q>.
    En dâ€™autres termes, il sâ€™agÃ®t de lâ€™ensemble des transformations qui permettent lâ€™encodage des caractÃ¨res dâ€™un
    rÃ©pertoireÂ :
</p>
<ol>
    <li>
        Un <strong lang="en">Coded Character Set</strong> assigne des points de code (<i lang="en">code points</i>)
        aux caractÃ¨res. Par exemple le <i lang="en">Universal Coded Character Set</i> assigne le point de code
        <code>U+1F635</code> au caractÃ¨re ğŸ˜µ.
    </li>
    <li>
        Une <strong lang="en">Character Encoding Form</strong> transforme ces points de code en sÃ©quences de bits de
        taille fixe (<i lang="en">code units</i>). Par exemple UTF-16 transformera <code>U+1F635</code> en
        <code>0xD83D 0xDE35</code>Â ; deux <i lang="en">code units</i> deâ€¦ 16Â bitsÂ !
    </li>
    <li>
        Un <strong lang="en">Character Encoding Scheme</strong> transforme ces <i lang="en">code units</i> en sÃ©quences
        dâ€™octets. Par exemple UTF-16LE (pour
        <a href="https://fr.wikipedia.org/wiki/Endianness#Little_endian"><i lang="en">Little Endian</i></a>)
        transformera <code>0xD83D 0xDE35</code> en <code>0x3D 0xD8 0x35 0xDE</code>.
    </li>
</ol>
<p>
    Le <i lang="en">charset</i> de notre exemple transforme ğŸ˜µÂ â€” une sÃ©quence dâ€™un caractÃ¨reÂ â€” en
    <code>0x3D 0xD8 0x35 0xDE</code>Â â€” une sÃ©quence dâ€™octets sÃ©rialisÃ©e.
</p>
<p>Pour Ã©viter toute ambiguÃ¯tÃ©, on prÃ©fÃ¨rera parler de <strong lang="en">Character Map</strong>.</p>
</html>
